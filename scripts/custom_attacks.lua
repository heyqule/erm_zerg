---
--- Extends or overrides CustomAttackHelper functions
--- Mod specific data pass around with remote.call()
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 12/23/2020 8:27 PM
---

local CustomAttackHelper = require("__enemyracemanager__/lib/helper/custom_attack_helper")
local ERMConfig = require("__enemyracemanager__/lib/global_config")


local CustomAttacks = CustomAttackHelper

local update_boss_data = function()
    if not storage.boss_data or not storage.boss_data.entity or storage.boss_data_cache_time + 3600 < game.tick then
        storage.boss_data_cache_time = game.tick
        storage.boss_data = remote.call("enemyracemanager","get_boss_data")
    end
end

function CustomAttacks.process_overlord(event)
    local race_settings = CustomAttackHelper.get_race_settings(MOD_NAME)
    CustomAttackHelper.drop_unit(event, MOD_NAME, "broodling", 3)
    CustomAttackHelper.drop_unit(event, MOD_NAME, "scourge", 2)
    if CustomAttackHelper.can_spawn(75) then
        CustomAttackHelper.drop_unit(event, MOD_NAME, CustomAttackHelper.get_unit(MOD_NAME, "droppable_units"))
    end
    if race_settings.tier == 3 and CustomAttackHelper.can_spawn(40) then
        CustomAttackHelper.drop_unit(event, MOD_NAME, "zergling", 2)
        if CustomAttackHelper.can_spawn(20) then
            CustomAttackHelper.drop_unit(event, MOD_NAME,  CustomAttackHelper.get_unit(MOD_NAME, "droppable_units"))
        end
    end
end

function CustomAttacks.process_queen(event)
    local race_settings = CustomAttackHelper.get_race_settings(MOD_NAME)
    CustomAttackHelper.drop_unit_at_target(event, MOD_NAME, "broodling", 2)
    if CustomAttackHelper.can_spawn(33) then
        CustomAttackHelper.drop_unit_at_target(event, MOD_NAME, "broodling", 1)
    end
    if race_settings.tier == 3 and CustomAttackHelper.can_spawn(10) then
        CustomAttackHelper.drop_unit_at_target(event, MOD_NAME, "zergling", 2)
    end
end

function CustomAttacks.process_scourge_spawn(event)
    CustomAttackHelper.drop_unit(event, MOD_NAME, "scourge", 1)
end

function CustomAttacks.process_drone(event)
    CustomAttackHelper.build(event, MOD_NAME, CustomAttackHelper.get_unit(MOD_NAME, "construction_buildings"))
    event.source_entity.destroy()
end


function CustomAttacks.process_boss_units(event, batch_size)
    batch_size = batch_size or 12
    CustomAttackHelper.drop_boss_units(event, MOD_NAME, ERMConfig.batch_spawn_size * batch_size)
end

function CustomAttacks.process_batch_units(event, batch_size)
    batch_size = batch_size or 12
    CustomAttackHelper.drop_batch_units(event, MOD_NAME, ERMConfig.batch_spawn_size * batch_size)
end

---
--- Handles aftermath of demolisher unit attack, process 20 units per batch.
--- Either build a base or kill themselves
---
function CustomAttacks.demolisher_units_attack()
    local i = 0
    local unit_group = {}
    for surface, units in pairs(storage.demolisher_units) do
        for key, unit_data in pairs(units) do
            local unit = unit_data.entity
            if unit.valid then
                local commandable = unit.commandable
                if (commandable.has_command == false or
                        commandable.command.type == defines.command.wander or
                        (commandable.command.type == defines.command.compound and commandable.command.commands[1].type == defines.command.wander)
                ) then
                    table.insert(unit_group, unit)
                    storage.demolisher_units[surface][key] = nil
                end
            elseif unit.valid == false then
                storage.demolisher_units[surface][key] = nil
            end
            i = i + 1
            if i == 20 then
                break
            end
        end

        local surface_group
        for _, unit in pairs(unit_group) do
            if surface_group == nil then
                surface_group = unit.surface.create_unit_group({position = unit.position, force = unit.force})
            end

            surface_group.add_member(unit)
        end

        if surface_group then
            --- either build base or die.
            if CustomAttacks.can_spawn(33) then
                remote.call("enemyracemanager", "build_base_formation", surface_group)
            else
                remote.call("enemyracemanager", "process_attack_position", {
                    group = surface_group,
                    distraction = defines.distraction.by_anything,
                    target_force = 'player',
                })
            end
        end
    end
end

function CustomAttacks.process_egg(event)
    -- Remove source_entity to prevent drop_unit() using it to get unit level.
    event.source_entity = nil
    local unit_name = "zergling"
    local amount = 2
    if CustomAttackHelper.can_spawn(10) then
        unit_name =  "ultralisk"
        amount = 1
    elseif CustomAttackHelper.can_spawn(20) then
        unit_name = "drone"
        amount = 1        
    elseif CustomAttackHelper.can_spawn(33) then
        unit_name = "mutalisk"
        amount = 1
    elseif CustomAttackHelper.can_spawn(50) then
        unit_name = "hydralisk"
        amount = 1
    end
    CustomAttackHelper.drop_unit(event, MOD_NAME, unit_name, amount)
end

-- Spawn 4 support spawner structures
function CustomAttacks.boss_spawned(event)
    if not event.source_entity then
        return
    end
    
    local boss_entity = event.source_entity
    local position = boss_entity.position
    
    local positions = {
        {x = 16, y = 16},
        {x = 16, y = -16},
        {x = -16, y = 16},
        {x = -16, y = -16}
    }

    local race_settings = CustomAttacks.get_race_settings(MOD_NAME, true)
    local assisted_spawner_name = race_settings.boss_assisted_spawner
    for _, offset in ipairs(positions) do
        local entity = CustomAttacks.boss_build(event, MOD_NAME, assisted_spawner_name, 
            {x = position.x + offset.x, y = position.y + offset.y})
    end
end

function CustomAttacks.boss_assisted_spawner_dies(event)
    local spawner_entity = event.source_entity
    if not spawner_entity then
        return
    end
    
    update_boss_data()
    if not storage.boss_data or not storage.boss_data.radar.valid then
        return
    end        
    local surface = spawner_entity.surface
    local position = spawner_entity.position

    local unit_group =  surface.create_unit_group({position = position, force = MOD_NAME})
    for i = 1, 10 do
        local member = surface.create_entity({
            name = MOD_NAME..'--broodling--6',
            position = position,
            force = MOD_NAME
        })
        unit_group.add_member(member)
    end
    unit_group.set_command(
        {
            type = defines.command.attack_area,
            destination = storage.boss_data.radar.position,
            radius = 16,
            distraction = defines.distraction.by_anything
        }
    )
end



return CustomAttacks